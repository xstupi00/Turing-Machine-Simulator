# FLP-PROJECT 2020 - LOGICAL PROJECT - TURING MACHINE

## EXAMPLE OF THE USAGE
* BUILD: `make`
* EXAMPLE RUN: `make run`
* ARBITRARY RUN: `./flp20-log < /tests/04.in`

## PROGRAM DESCRIPTION
A program implements the simulation of the non-deterministic Turing Machines.
The program reads the transitions and initial content of the machine tape
from the standard input. The transitions have to be in the required following
format: `State, Symbol, NewState, NewSymbol`, where `State` and `NewState` are
in the range `[A-Z]`, `Symbol` and `NewSymbol` are within the range `[a-z]`,
or they can be also `space`, which represents the `blank` symbol on the 
machine tape. Moreover, the `NewSymbol` can be equal to `L` or `R`, which 
represents the shift of the machine head to the left or right. The states
`S` and `F` represents the starting respectively the finish state of the
given machine. The initial content of the machine tape has to be symbols 
within the range `[a-z]` and it has to be in the last line of the input. 
The example inputs you can find in the [test][1] directory, respectively in 
the `*.in` files.

## IMPLEMENTATION
In the beginning, the given input is loading and subsequently, it is stored
to the internal representation. We note, when some transition has not the
required format, then it will ignore during the simulation of the given
machine. The correctly loaded transitions are storing to the database before
the start of the simulation (`transition`). Into the database is also stored
the initial configuration, which consists of the initial state `S` and
given initial content of the machine tape (`paths`). In the first step, the 
simulation finds all firing transitions from this configuration. Subsequently, 
these transitions are fired and are constructed the new reachable 
configurations. These newly constructed configurations are appended to the 
stored paths in the database. After the first step will be in the database 
stored only the paths with the length equal to two. When some newly 
constructed configuration includes the final state `F`, then the computation 
halts, otherwise, the next step is performed for these configurations. 
Thus, in this way, after each step, we obtain all reachable configurations 
after the  relevant number of performed transitions, and in the database 
will be stored the paths from the initial configuration to these reachable 
configurations. In this iterative way, we will research all reachable
computation paths, and we are so guaranteed that if there is any path to 
the final state `F`, the simulation will find it. At the end of the
computation, when was founded path to the final state, then it is written
out to the standard output.

### END OF THE SIMULATION
The simulation of the computation of the Turing Machine can terminate in the
following different way. When exists the path from the initial configuration
to the configuration which including the final state, then it will be found
and write out to the standard output. When such the path does not exist
and the machine does not offer any other fireable transitions, then 
the computation will halt with the message about the abnormally stopping.
To this option also belongs the not allowed the shift of the machine head
to the left outside the machine tape. The last possibility is that the 
machine contains an infinite path where infinitely many transitions are 
fired, in which case the simulation does not end spontaneously.

## AUTOMATION TESTS
The [test][1] directory contains the shell [script][2] that serves
to automatic testing the correctness of this program. In total, the
test directory includes **13** different inputs, which are considered
to various aspects of the simulation such as possible infinite iterating
when the final path exists ([test_10][3]), potential delta symbols within 
transitions ([test_6][4]) or inputs that do not include the finite
final paths ([test_3][5]), and much more. To run the shell [script][2]
you can use the following command:
```
make test
```
The output will be contained the resulting summaries from tested suites. 
When some test is not successful, then is also printed the expected 
solution in comparison to the solution generated by the program.

## RUNNING TIMES
We list the run-times of the simulation at the individual testing
inputs from the attached [directory][1]:

* [01][6]: 0.080s (2); [02][7]: 0.071s (4); [03][5]: 0.066s (e)
* [04][8]: 0.083s (8); [05][9]: 0.056s (5); [06][4]: 0.066s (4)
* [07][10]: 0.054s (5); [08][11]: 0.086s (e); [09][12]: 2.814s (35)
* [10][3]: 0.069s (8); [11][13]: 0.061s (4); [12][14]: 0.065s (8)
* [13][15]: 0.055s (e)


[1]: /tests
[2]: /tests/run_tests.sh
[3]: /tests/10.in
[4]: /tests/06.in
[5]: /tests/03.in
[6]: /tests/01.in
[7]: /tests/02.in
[8]: /tests/04.in
[9]: /tests/05.in
[10]: /tests/07.in
[11]: /tests/08.in
[12]: /tests/09.in
[13]: /tests/11.in
[14]: /tests/12.in
[15]: /tests/13.in